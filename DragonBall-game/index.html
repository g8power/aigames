<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>七龍珠Z：那美剋星激戰</title>
    <style>
        body { margin: 0; padding: 0; background: #000; overflow: hidden; touch-action: none; }
        canvas { display: block; margin: 0 auto; }
    </style>
    <script src="phaser.min.js"></script>
</head>
<body>

<script>
// ==========================================
// 1. 定義所有的場景類別
// ==========================================

class PreloadScene extends Phaser.Scene {
    constructor() { super('PreloadScene'); }
    preload() {
        // 載入條
        let progressBar = this.add.graphics();
        let progressBox = this.add.graphics();
        progressBox.fillStyle(0x222222, 0.8);
        progressBox.fillRect(this.cameras.main.width / 2 - 160, this.cameras.main.height / 2 - 25, 320, 50);
        
        this.load.on('progress', (value) => {
            progressBar.clear();
            progressBar.fillStyle(0x40E0D0, 1); // 那美剋星綠
            progressBar.fillRect(this.cameras.main.width / 2 - 150, this.cameras.main.height / 2 - 15, 300 * value, 30);
        });

        // --- 載入使用者提供的素材 ---
        // 請確保這些檔案放在 assets 資料夾中，或是與 index.html 同層
        this.load.image('bg_sky', 'assets/bg_namek_sky.png');
        this.load.image('bg_mountains', 'assets/bg_namek_mountains.png');
        this.load.image('tile_ground', 'assets/tile_namek_ground.png');
        this.load.image('obj_tree', 'assets/obj_ajisa_tree.png');

        // 另外生成弗利札和龍珠的暫時貼圖 (因為你只提供了場景圖)
        this.makeTempAssets();
    }

    create() { this.scene.start('TitleScene'); }

    makeTempAssets() {
        let graphics = this.make.graphics({x: 0, y: 0, add: false});

        // 弗利札座艙
        graphics.clear();
        graphics.fillStyle(0xFFFFFF, 1);
        graphics.fillCircle(20, 20, 20);
        graphics.fillStyle(0x800080, 1); // 紫色內裝
        graphics.fillCircle(20, 16, 10);
        graphics.generateTexture('frieza_pod', 40, 40);

        // 龍珠 (橘色球體)
        graphics.clear();
        graphics.fillStyle(0xFFA500, 1);
        graphics.fillCircle(15, 15, 15);
        graphics.fillStyle(0xFF0000, 1); // 星星
        graphics.fillCircle(15, 15, 4);
        graphics.generateTexture('dragonball', 30, 30);

        // 氣功特效
        graphics.clear();
        graphics.fillStyle(0xFFFFFF, 1);
        graphics.fillCircle(5, 5, 5);
        graphics.generateTexture('energy_bit', 10, 10);
    }
}

class TitleScene extends Phaser.Scene {
    constructor() { super('TitleScene'); }
    create() {
        // 使用新的天空當標題背景
        this.add.image(this.cameras.main.centerX, this.cameras.main.centerY, 'bg_sky').setDisplaySize(this.scale.width, this.scale.height);

        const cx = this.cameras.main.centerX;
        const cy = this.cameras.main.centerY;
        
        this.add.text(cx, cy - 60, 'PLANET NAMEK', { fontSize: '60px', color: '#FFF', stroke: '#000', strokeThickness: 6, fontStyle: 'bold' }).setOrigin(0.5);
        this.add.text(cx, cy, 'BATTLE', { fontSize: '40px', color: '#FFD700', stroke: '#000', strokeThickness: 4, fontStyle: 'bold' }).setOrigin(0.5);
        
        let startBtn = this.add.text(cx, cy + 100, 'START GAME', { fontSize: '32px', backgroundColor: '#008000', padding: {x:30, y:15} })
            .setOrigin(0.5).setInteractive().on('pointerdown', () => this.scene.start('GameScene'));
        this.tweens.add({ targets: startBtn, scaleX: 1.1, scaleY: 1.1, duration: 800, yoyo: true, repeat: -1 });
    }
}

class GameScene extends Phaser.Scene {
    constructor() { super('GameScene'); }

    create() {
        this.scene.launch('UIScene');
        this.physics.world.setBounds(0, 0, Number.MAX_SAFE_INTEGER, this.scale.height);
        this.groundY = this.scale.height - 60;
        
        // --- 1. 背景層 (Sky) ---
        // 固定不動，或者極慢移動
        this.bgSky = this.add.tileSprite(0, 0, this.scale.width, this.scale.height, 'bg_sky')
            .setOrigin(0)
            .setScrollFactor(0); // 鎖定在鏡頭上

        // --- 2. 遠景山脈 (Mountains) - 視差滾動核心 ---
        // 將圖片設為 tileSprite，高度設為 300 (依圖片調整)，並置於地面上方
        this.bgMountains = this.add.tileSprite(0, this.groundY, this.scale.width, 400, 'bg_mountains')
            .setOrigin(0, 1) // 定位點設在左下角
            .setScrollFactor(0); // 我們手動控制它的 X 位移來製造視差
            
        // --- 3. 地面層 (Ground) ---
        // 使用 tile_namek_ground
        this.ground = this.add.tileSprite(0, this.groundY, this.scale.width, 80, 'tile_ground')
            .setOrigin(0, 0)
            .setScrollFactor(0); 

        // 物理地板 (隱形)
        this.platforms = this.physics.add.staticGroup();
        let floor = this.platforms.create(this.scale.width/2, this.scale.height - 10, 'tile_ground').setScale(1000, 2).refreshBody();
        floor.setVisible(false);

        // 玩家 (悟飯)
        this.player = this.add.rectangle(200, this.groundY - 50, 40, 80, 0xFFA500); 
        this.add.text(180, this.groundY - 100, "GOHAN", {fontSize: '12px', color: '#FFF', stroke: '#000', strokeThickness: 2});

        // 弗利札
        this.frieza = this.physics.add.image(250, this.groundY - 30, 'frieza_pod');
        this.frieza.setCircle(20);
        this.frieza.setBounce(0.6);
        this.frieza.setCollideWorldBounds(true);
        this.physics.world.setBoundsCollision(false, false, false, true);
        this.physics.add.collider(this.frieza, this.platforms, this.onGroundHit, null, this);

        // 鏡頭設定
        this.cameras.main.startFollow(this.frieza, true, 0.08, 0.08);
        this.cameras.main.setFollowOffset(-200, 100);

        this.obstacles = this.physics.add.group();
        this.isAiming = false;
        this.gameState = 'IDLE';

        this.graphics = this.add.graphics();
        this.input.on('pointerdown', this.startAim, this);
        this.input.on('pointermove', this.updateAim, this);
        this.input.on('pointerup', this.shoot, this);

        // 氣焰特效
        this.trail = this.add.particles(0, 0, 'energy_bit', {
            speed: 100, scale: { start: 0.8, end: 0 }, blendMode: 'ADD', lifespan: 300, 
            tint: 0xFF00FF, follow: this.frieza 
        });
        this.trail.stop();
    }

    update(time, delta) {
        // --- 視差滾動邏輯 (Parallax) ---
        
        // 1. 地面：跟隨鏡頭速度 (1:1)
        this.ground.tilePositionX = this.cameras.main.scrollX;

        // 2. 山脈：移動速度是鏡頭的 0.2 倍 (看起來很遠)
        this.bgMountains.tilePositionX = this.cameras.main.scrollX * 0.2;

        const floor = this.platforms.getChildren()[0];
        floor.x = this.frieza.x;
        floor.refreshBody();

        if (this.gameState === 'FLYING') {
            this.frieza.rotation += this.frieza.body.velocity.x * 0.002;
            this.generateObstacles();

            // 物理阻力：草地摩擦力
            if (this.frieza.body.onFloor()) {
                this.frieza.setDragX(400); 
                this.frieza.setAngularDrag(400);
            } else {
                this.frieza.setDragX(30); 
                this.frieza.setAngularDrag(0);
            }

            if (Math.abs(this.frieza.body.velocity.x) < 5 && Math.abs(this.frieza.body.velocity.y) < 5 && this.frieza.body.onFloor()) {
                this.frieza.setVelocity(0);
                this.trail.stop();
                this.gameState = 'ENDED';
                this.scene.get('UIScene').showRestart();
            }

            let dist = Math.max(0, Math.floor((this.frieza.x - 250) / 10));
            this.events.emit('updateScore', dist);
        }
    }

    startAim(pointer) {
        if (this.gameState !== 'IDLE') return;
        this.isAiming = true;
    }

    updateAim(pointer) {
        if (!this.isAiming) return;
        this.graphics.clear();
        let worldPoint = pointer.positionToCamera(this.cameras.main);
        let dx = worldPoint.x - this.frieza.x;
        let dy = worldPoint.y - this.frieza.y;
        let angle = Math.atan2(dy, dx);
        if (dx < 0) angle = -1.5; 

        const lineLen = 150;
        this.graphics.lineStyle(4, 0xFF0000, 1);
        this.graphics.beginPath();
        this.graphics.moveTo(this.frieza.x, this.frieza.y);
        this.graphics.lineTo(this.frieza.x + Math.cos(angle) * lineLen, this.frieza.y + Math.sin(angle) * lineLen);
        this.graphics.strokePath();
        this.currentAimAngle = angle;
    }

    shoot() {
        if (!this.isAiming) return;
        this.isAiming = false;
        this.graphics.clear();
        this.gameState = 'FLYING';

        const power = 1000;
        this.frieza.setVelocity(Math.cos(this.currentAimAngle) * power, Math.sin(this.currentAimAngle) * power);
        this.cameras.main.shake(200, 0.01);
        this.trail.start();
    }

    generateObstacles() {
        let spawnX = this.cameras.main.scrollX + this.scale.width + 100;
        let lastItem = this.obstacles.getLast(true);
        if (lastItem && lastItem.x > spawnX - 400) return;

        if (Phaser.Math.Between(0, 100) < 6) {
            let type = Math.random() < 0.3 ? 'TREE' : 'DRAGONBALL';
            
            // 決定要生成什麼：樹木(障礙) 或 龍珠(加速)
            // 注意：因為您的樹木圖片包含兩樣東西，這裡可能會顯示整張圖，建議之後裁切
            let texture = type === 'TREE' ? 'obj_tree' : 'dragonball';
            
            let yPos = this.groundY - 40; 
            if (type === 'TREE') yPos = this.groundY - 80; // 樹要長在地上，位置調高一點

            let obs = this.obstacles.create(spawnX, yPos, texture);
            
            // 樹木貼圖可能很大，我們縮放一下
            if(type === 'TREE') {
                obs.setScale(0.5); 
                obs.body.setSize(obs.width * 0.4, obs.height * 0.8); // 縮小碰撞框，避免撞到空氣
                obs.setOffset(obs.width * 0.3, obs.height * 0.2);
            }

            obs.body.allowGravity = false;
            obs.body.setImmovable(true);
            obs.type = type;
            
            this.physics.add.overlap(this.frieza, obs, this.hitObstacle, null, this);
        }
        this.obstacles.children.each(obs => { if (obs.x < this.cameras.main.scrollX - 100) obs.destroy(); });
    }

    hitObstacle(frieza, obstacle) {
        obstacle.disableBody(true, true);
        this.cameras.main.shake(300, 0.02);

        if (obstacle.type === 'DRAGONBALL') {
            // 加速
            let currentVel = frieza.body.velocity;
            frieza.setVelocity(Math.max(currentVel.x * 1.3, 900), -350); 
            this.cameras.main.flash(100, 255, 255, 255);
            this.createExplosion(obstacle.x, obstacle.y, 0xFFD700);
        } else {
            // 撞到樹 (障礙)
            frieza.setVelocity(-150, -200);
            this.cameras.main.flash(100, 255, 0, 0); 
            this.createExplosion(obstacle.x, obstacle.y, 0x00FF00); // 綠色爆炸
        }
    }

    onGroundHit() {
        if (Math.abs(this.frieza.body.velocity.y) > 100) {
            this.cameras.main.shake(100, 0.005);
        }
    }

    createExplosion(x, y, color) {
        let emitter = this.add.particles(x, y, 'energy_bit', {
            speed: { min: 50, max: 250 }, angle: { min: 0, max: 360 }, scale: { start: 1, end: 0 },
            blendMode: 'ADD', lifespan: 500, gravityY: 200, tint: color, quantity: 30
        });
        this.time.delayedCall(500, () => emitter.destroy());
    }
}

class UIScene extends Phaser.Scene {
    constructor() { super('UIScene'); }
    create() {
        this.scoreText = this.add.text(20, 20, '距離: 0 M', { fontSize: '24px', fontStyle: 'bold', color: '#FFF', stroke: '#000', strokeThickness: 4 });
        let gameScene = this.scene.get('GameScene');
        gameScene.events.on('updateScore', (score) => { this.scoreText.setText('距離: ' + score + ' M'); });
        
        this.restartBtn = this.add.text(this.cameras.main.centerX, this.cameras.main.centerY, '再戰一場', {
            fontSize: '32px', backgroundColor: '#FF4500', padding: {x:20, y:10}, fontStyle: 'bold'
        }).setOrigin(0.5).setInteractive().setVisible(false).on('pointerdown', () => {
            this.scene.stop('GameScene'); this.scene.start('GameScene');
        });
    }
    showRestart() { this.restartBtn.setVisible(true); }
}

const config = {
    type: Phaser.AUTO, width: window.innerWidth, height: window.innerHeight, backgroundColor: '#222',
    scale: { mode: Phaser.Scale.FIT, autoCenter: Phaser.Scale.CENTER_BOTH },
    physics: { default: 'arcade', arcade: { gravity: { y: 600 }, debug: false } },
    scene: [PreloadScene, TitleScene, GameScene, UIScene]
};
const game = new Phaser.Game(config);
</script>
</body>
</html>