<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>極限窄縫 - Hardcore Runner</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #000; /* 全黑背景 */
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Courier New', Courier, monospace; /* 科技感字體 */
            overflow: hidden;
        }

        #gameCanvas {
            background-color: #2c3e50;
            border: 4px solid #fff;
            box-shadow: 0 0 30px rgba(255, 0, 0, 0.4); 
            display: block;
        }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            text-align: center;
            pointer-events: none;
            width: 100%;
        }

        .score {
            font-size: 32px;
            color: #fff;
            font-weight: bold;
            text-shadow: 0 0 10px #3498db;
        }

        #gameOverScreen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(20, 20, 20, 0.95);
            color: #e74c3c;
            padding: 40px 60px;
            border: 2px solid #e74c3c;
            border-radius: 0;
            text-align: center;
            display: none;
            z-index: 10;
            box-shadow: 0 0 50px rgba(231, 76, 60, 0.5);
        }

        h1 { margin: 0 0 20px 0; font-size: 40px; text-transform: uppercase; letter-spacing: 5px; }
        
        button {
            background-color: transparent;
            border: 2px solid #fff;
            color: white;
            padding: 15px 40px;
            font-size: 20px;
            cursor: pointer;
            margin-top: 30px;
            transition: 0.2s;
            font-family: inherit;
            font-weight: bold;
        }
        
        button:hover {
            background-color: #fff;
            color: #000;
        }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="score"><span id="scoreVal">0</span> M</div>
    </div>

    <div id="gameOverScreen">
        <h1>CRASHED</h1>
        <p style="color: #bbb; margin-bottom: 5px;">距離</p>
        <p style="color: white; font-size: 30px; margin-top:0;"><span id="finalScore">0</span> M</p>
        <button onclick="resetGame()">RETRY</button>
    </div>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const scoreEl = document.getElementById('scoreVal');
        const finalScoreEl = document.getElementById('finalScore');
        const gameOverScreen = document.getElementById('gameOverScreen');

        // 遊戲變數
        let gameRunning = true;
        let score = 0;
        let frameCount = 0;
        
        // --- 設定 1: 初始極速 ---
        let gameSpeed = 11; 

        // 輸入狀態
        let isMouseDown = false;

        // 主角設定 (加強反應靈敏度)
        const player = {
            x: 100,
            y: 200,
            width: 30,  // 主角高度 30
            height: 30,
            color: '#00d2d3', // 亮青色
            dy: 0,
            gravity: 1.2,    // 重力極強，放開馬上掉
            lift: -2.2,      // 上升力極強，按住馬上飛
            maxFallSpeed: 15,
            maxLiftSpeed: -15
        };

        let obstacles = [];

        // 監聽
        canvas.addEventListener('mousedown', () => isMouseDown = true);
        canvas.addEventListener('mouseup', () => isMouseDown = false);
        canvas.addEventListener('mouseleave', () => isMouseDown = false);
        canvas.addEventListener('touchstart', (e) => { e.preventDefault(); isMouseDown = true; });
        canvas.addEventListener('touchend', (e) => { e.preventDefault(); isMouseDown = false; });

        // --- 設定 2: 嚴格縫隙生成器 ---
        function spawnObstacle() {
            const obsWidth = 60; // 障礙物寬度
            
            // 計算縫隙大小：介於 55px (1.8倍) 到 75px (2.5倍) 之間
            const gapHeight = Math.random() * 20 + 55; 
            
            // 計算縫隙的垂直位置 (留出上下邊界緩衝，避免縫隙完全貼頂或貼地)
            const minPadding = 30;
            const maxGapY = canvas.height - minPadding - gapHeight;
            const gapY = Math.random() * (maxGapY - minPadding) + minPadding;

            // 生成上方的柱子
            obstacles.push({
                x: canvas.width,
                y: 0,
                width: obsWidth,
                height: gapY, // 從頂部延伸到縫隙上緣
                color: '#e74c3c' // 紅色危險
            });

            // 生成下方的柱子
            obstacles.push({
                x: canvas.width,
                y: gapY + gapHeight, // 從縫隙下緣開始
                width: obsWidth,
                height: canvas.height - (gapY + gapHeight), // 延伸到底部
                color: '#e74c3c'
            });
        }

        function update() {
            if (!gameRunning) return;

            // 物理
            if (isMouseDown) {
                player.dy += player.lift;
            } else {
                player.dy += player.gravity;
            }

            // 限制極速
            if (player.dy > player.maxFallSpeed) player.dy = player.maxFallSpeed;
            if (player.dy < player.maxLiftSpeed) player.dy = player.maxLiftSpeed;

            player.y += player.dy;

            // 撞天花板或地板直接死亡
            if (player.y + player.height > canvas.height || player.y < 0) {
                gameOver();
            }

            // --- 設定 3: 配合高速的生成頻率 ---
            // 速度越快，需要的生成間隔幀數越少，保持畫面上的障礙密度
            // 當速度 11 時，約 35 幀生成一次
            if (frameCount % 35 === 0) {
                spawnObstacle();
            }

            for (let i = 0; i < obstacles.length; i++) {
                let obs = obstacles[i];
                obs.x -= gameSpeed;

                if (obs.x + obs.width < 0) {
                    obstacles.splice(i, 1);
                    i--;
                    continue;
                }

                // 碰撞檢測 (稍微寬容 3px)
                const hitPadding = 3; 
                if (
                    player.x + hitPadding < obs.x + obs.width &&
                    player.x + player.width - hitPadding > obs.x &&
                    player.y + hitPadding < obs.y + obs.height &&
                    player.y + player.height - hitPadding > obs.y
                ) {
                    gameOver();
                }
            }

            score++;
            frameCount++;
            scoreEl.innerText = Math.floor(score / 10);
            
            // 隨時間變得更瘋狂的快
            if (frameCount % 1000 === 0) {
                gameSpeed += 1;
                // 速度上限 20，不然人類無法反應
                if(gameSpeed > 20) gameSpeed = 20;
            }

            requestAnimationFrame(draw);
        }

        function draw() {
            if (!gameRunning) return;

            // 背景加上動態線條感 (簡單模擬速度線)
            ctx.fillStyle = '#2c3e50';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // 畫一些背景裝飾讓速度感更強
            ctx.fillStyle = '#34495e';
            for(let i=0; i<10; i++) {
                let speedLineX = (frameCount * gameSpeed + i * 100) % canvas.width;
                let speedLineY = (i * 40 + 20);
                ctx.fillRect(canvas.width - speedLineX, speedLineY, 40, 2);
            }

            // 畫主角
            ctx.shadowBlur = 15;
            ctx.shadowColor = player.color;
            ctx.fillStyle = player.color;
            ctx.fillRect(player.x, player.y, player.width, player.height);
            ctx.shadowBlur = 0; // 重置陰影

            // 畫尾焰
            if (isMouseDown) {
                ctx.fillStyle = '#fff';
                ctx.beginPath();
                ctx.moveTo(player.x, player.y + player.height);
                ctx.lineTo(player.x - 10, player.y + player.height + 10);
                ctx.lineTo(player.x + player.width, player.y + player.height);
                ctx.fill();
            }

            // 畫障礙物
            for (let obs of obstacles) {
                // 畫危險的斜線紋路
                ctx.fillStyle = obs.color;
                ctx.fillRect(obs.x, obs.y, obs.width, obs.height);
                
                // 裝飾：給障礙物加亮邊
                ctx.fillStyle = '#c0392b';
                ctx.fillRect(obs.x, obs.y, 5, obs.height); // 左邊緣
            }
            
            requestAnimationFrame(update);
        }

        function gameOver() {
            gameRunning = false;
            finalScoreEl.innerText = Math.floor(score / 10);
            gameOverScreen.style.display = 'block';
        }

        function resetGame() {
            player.y = 200;
            player.dy = 0;
            obstacles = [];
            score = 0;
            frameCount = 0;
            gameSpeed = 11; // 重置回高速
            gameRunning = true;
            isMouseDown = false;
            gameOverScreen.style.display = 'none';
            update();
        }

        update();
        draw();

    </script>
</body>
</html>